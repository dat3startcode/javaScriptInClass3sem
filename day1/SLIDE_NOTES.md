1. scripted (talk about interpreter vs compiler)
2. event-driven (talk about events like keypress, mouseclick, etc. and how they are handled in JS)
3. high-level (talk about garbage collection, dynamic typing, etc.)
4. dynamic (talk about dynamic typing instead of static typing)
5. prototype-based (everything is an object, apart from primitives, and objects inherit from other objects. )
6. first-class functions (functions are treated as variables, pass them into other functions, return them from functions, etc.)
7. multi-paradigm (talk about functional, object-oriented, and procedural programming)


- Statically typed programming languages do type checking at compile-time. Examples: Java, C, C++.
- Dynamically typed programming languages do type checking at run-time. Examples: Perl, Ruby, Python, PHP, JavaScript.


### What is the difference between a compiler and an interpreter?

A compiler and an interpreter are both types of software that are used to translate human-readable code
(often written in a high-level programming language) into machine-readable code (often in the form of machine code or
bytecode).

The main difference between a compiler and an interpreter lies in how they accomplish this task:

#### Compiler:

A compiler is a program that translates the entire source code into an executable form. It takes the entire source code
as input
and generates an executable program or a binary file that can be directly executed by the computer. The compilation
process includes several
stages such as lexical analysis, syntax analysis, semantic analysis, code optimization, and code generation. The output
of the compiler is usually
faster and more efficient than that of an interpreter because the source code is converted to machine code before it is
executed.

#### Interpreter:

An interpreter is a program that reads and executes the source code line by line. It does not generate an executable
program like a compiler does.
Instead, it interprets each line of code, translates it into machine code, and executes it. The interpretation process
includes lexical analysis,
syntax analysis, and semantic analysis. The output of an interpreter is slower than that of a compiler because the
source code is translated into machine
code at runtime, and there is no opportunity for code optimization.

In summary, the main difference between a compiler and an interpreter is that a compiler generates an executable program
by translating the entire
source code, while an interpreter translates and executes the source code line by line. Both compilers and interpreters
have their own advantages
and disadvantages, and the choice between them depends on the specific needs and requirements of the programming
project.

### What does it mean a programming language to be scripted?

A programming language is considered to be "scripted" when it is primarily used for creating scripts or programs that
automate specific tasks or
processes. Scripting languages are often interpreted rather than compiled, and they are typically designed to be easy to
write and understand,
with a focus on rapid development and prototyping.

Scripting languages are often used in situations where the speed of execution is not the primary concern, but rather the
ease of writing and
maintaining code. They are commonly used in tasks such as automation of system administration tasks, web scripting, and
in the development of
simple applications or prototypes.

Some examples of popular scripting languages include Python, Ruby, Perl, JavaScript, and Bash. These languages are often
used for a wide
range of purposes, from web development and data analysis to system administration and automation.

Overall, the term "scripted" simply refers to a programming language that is designed to be used for scripting or
automation tasks,
with a focus on simplicity, ease of use, and rapid development.

### What does it mean a programming to be event-driven?

An event-driven programming language is a programming language that is designed to respond to events or actions that
occur within a program or system.
In an event-driven program, the program responds to events that are generated by user actions, such as mouse clicks,
keystrokes, or other inputs, as well as
events generated by the system or other programs.

In an event-driven programming model, the program is organized around a set of events, which trigger the execution of
specific functions or procedures.
The program waits for events to occur, and when an event occurs, it invokes the appropriate function or procedure to
handle the event. This allows the program
to be highly responsive and interactive, as it can respond to user input and system events in real-time.

Event-driven programming is commonly used in user interface programming, where the program must respond to user input
and interact with the user in real-time.
It is also used in a variety of other applications, such as networking, multimedia, and gaming, where the program must
respond to a variety of events in real-time.

Some examples of event-driven programming languages include JavaScript, Python, Java, and C#. These languages provide a
variety of tools and libraries for
building event-driven applications, including event handlers, callbacks, and event loops, which allow developers to
create highly responsive and interactive
programs that can handle a wide range of events and inputs.

### What is a high-level programming language?

A dynamic programming language is a programming language that is designed to be flexible and easy to use, allowing
programmers to write code that can adapt and change at runtime.
Dynamic programming languages are often interpreted rather than compiled, and they typically feature a number of
features that allow for dynamic, flexible programming.

**Some common features of dynamic programming languages include:**

1. **Dynamic Typing:** In dynamic programming languages, data types are determined at runtime rather than at compile
   time. This allows for more flexibility in programming,
   as programmers can write code that can handle a wide variety of data types.
2. **Duck Typing:** Dynamic programming languages often use duck typing, which means that the type of an object is
   determined based on its behavior, rather than its class or type.
   This allows for more flexible programming, as programmers can write code that can handle a wide variety of object
   types.
3. **Garbage Collection:** Dynamic programming languages often feature automatic garbage collection, which frees up
   memory that is no longer being used by the program.
   This makes programming easier and more flexible, as programmers do not have to worry about managing memory manually.
4. **Runtime Code Execution:** Dynamic programming languages often allow for runtime code execution, which means that
   code can be executed while the program is running.
   This allows for more flexible programming, as programmers can write code that can adapt to changing conditions and
   requirements.

Some examples of popular dynamic programming languages include Python, Ruby, JavaScript, and PHP. These languages are
commonly used in a wide variety of applications,
including web development, data analysis, scientific computing, and more. Overall, dynamic programming languages provide
programmers with a flexible, adaptable,
and easy-to-use programming environment, making them a popular choice for many types of programming tasks.

### What is the difference between prototype-based and class-based programming language ?

Prototype-based and class-based programming are two different paradigms for object-oriented programming.
The main difference between them is in the way that objects are defined and created in the language.

In a class-based programming language, objects are created from classes, which are defined as blueprints for creating
objects.
A class defines the properties and behaviors that an object can have, and objects are created by instantiating a class.
In a class-based language,
inheritance is often used to create new classes that share properties and behaviors with existing classes.

In contrast, a prototype-based programming language uses prototypal inheritance to create objects. In this model,
objects are created from prototypes, which are essentially pre-existing objects that are used as templates for creating
new objects.
Objects can inherit properties and behaviors from their prototypes, and new prototypes can be created by cloning
existing prototypes.

The main advantage of prototype-based programming is its flexibility and dynamic nature. Objects can be easily created
and modified at runtime,
and there is no need to define a class hierarchy upfront. This makes prototype-based languages well-suited for
situations where a high degree of
flexibility is required, such as in web development or rapid prototyping.

Class-based programming, on the other hand, provides a more structured and predictable programming environment.
The use of classes allows for better code organization and reuse, and the class hierarchy provides a clear understanding
of h
ow objects relate to each other. This makes class-based languages well-suited for larger, more complex programming
projects.

Some examples of class-based programming languages include Java, C++, and C#. Examples of prototype-based programming
languages include JavaScript, Lua, and Self.

### High-level vs. low-level programming language

High-level and low-level programming languages are two different categories of programming languages.
The main difference between them is in the level of abstraction that they provide.
Example of low-level programming language is C, C++, and Assembly.
Example of high-level programming language is Python, Java, and JavaScript. High-level programming languages are often
interpreted rather than compiled, and they typically feature a high level of abstraction, making them easier to use and
understand.

High-level programming:

1. Garbage collection
2. Automatic memory management
3. Dynamic typing
4. Runtime code execution
5. High-level abstractions
6. Easy to learn and use

Low-level programming:

1. Manual memory management
2. Static typing
3. Compile-time code execution
4. Low-level abstractions

